#+TITLE: Signal Routing
* Overview
=Signal Routing= refers to the process of taking
the output signal of a unit generator, and transporting
it to be used as the input signal of another unit
generator.

Due to the lower-level nature of sndkit, routing is a
bit more involved compared to other softare
modular synthesis environments. But, with a little bit
of time, working with signals in sndkit becomes second
nature.
* A brief summary of how sndkit patches work
A "modular patch" constructed in sndkit has a more formal
name in the CS world: a directed acyclic graph, or DAG.
To make these graphs, sndkit uses a library called
=graforge=.

In a typical modular environment, one creates a bunch
of nodes, and then strings them together with cables. The
library then analyzes those connections and determines
which order to render the nodes. If A modulates B modulates
C, C can't be computed without first computing A and B.
In Graforge, this intermediate representation of
nodes and connections is skipped, and render order list
is populated directly. So, from above: a sndkit program
would explicitely compute A, take A and use it to compute
B, then take B and compute C. The render order is explicit
rather than implicit. This takes some getting used to,
but it makes for a much simpler codebase.

Signals are rendered in tiny chunks at time. These chunks
are known as =buffers=. Graforge uses a fixed-size
=buffer pool= that unit generators can read and write to.
A =buffer stack= interface is built on top of the buffer
pool as a way to manage signals.

Routing a signal in sndkit boils down to writing to a
buffer, and making sure that particular buffer can be
read by another unit generator later before it gets
overwritten by another signal.
* Serial Routing Using The Stack
Most signal routing tends to be done in =serial=, where
signals go right into eachother. An oscillator going
into a filter going into a gain control is an example
of a serial connection.

For serial connections, the stack is often invisible:

#+BEGIN_SRC lil
butlp [saw [mtof [add [sine 6 0.25] 60]] [param 0.5]] 300
#+END_SRC

This patch is very serial. A signal that gets generated
immediately gets used by the next unit generator. Under
the hood, generated signals are being pushed onto the
stack, and then immediately popped by the next unit
generator.

Taking advantage of the 'zz' operator, one can
break this patch out into multiple lines:

#+BEGIN_SRC lil
# LFO for vibrato
sine 6 0.25
# bias vibrato to MIDI note 60 (middle C)
add zz 60
# convert from MIDI to frequency
mtof zz
# use frequency to control sawtooth
blsaw zz
# lowpass filter the sawtooth
butlp zz 300
#+END_SRC

The 'zz' operator tells sndkit to pop the last item
on the stack as the parameter rather than use a
parameter.

Sometimes, there will be situations where a patch
is nearly serial, but has signal that wants to get
used more than once. For that, operations like dup/swap
can come in handy, which those familiar with Forth
will recognize.

The =dup= operation will "duplicate" (a link, not
a deep copy) the last item
on the stack. And "swap" will take the last two items
on the stack and swap their positions.

This patch below uses dup/swap to make a clock signal
generated by =metro= to control an envelope and a
random number generator for frequency in a sine wave:

#+BEGIN_SRC lil
metro 1
# stack: m
dup
# stack: m m
env zz 0.001 0.001 0.1
# stack: m e
swap
# stack: e m
trand zz 200 800
# stack: e t
sine zz 0.5
# stack: e s
mul zz zz
#+END_SRC

=dup= and =swap= are the only stack operations currently
implemented. There are two main reasons for this. One is
that the stack abstraction used in sndkit holds other
types other than buffers and implementing other operations
would be complicated. The second reason is that excessive
stack operations are discouraged. In sndkit,
they are easy to mess up, and difficult to debug. For
complex signal routing situations, buffer holding and
registers are recommended.
* TODO Cable holding and Registers
TBD.
* TODO Using Cabnew
TBD.
* TODO Creating sends/throws
TBD.
